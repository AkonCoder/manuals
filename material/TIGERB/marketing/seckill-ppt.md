# 业务概念

## 秒杀是什么

做系统概念很重要 尤其是电商系统

![](http://cdn.tigerb.cn/20200712224532.jpeg)
![](http://cdn.tigerb.cn/20200712224556.jpeg)
![](http://cdn.tigerb.cn/20200712224606.jpeg)

> 一种营销手段

营销维度
- 价格
- 数量
- 商品
- 时间

价格维度
- 白菜价
- 非白菜价

数量维度
- 极少(比如几个)
- 非极少

商品维度
- 爆品
- 非爆品

时间维度
- 限时

产生概念
- 白菜价+极少+(爆品或者非爆品)+限时 -> 一元秒杀之类
- 非白菜价+(极少或非极少)+(爆品或者非爆品)+限时 -> 限时购(又称常规秒杀) 
- 非白菜价+(极少或非极少)+(爆品)+限时 -> 爆品抢购

小米特色 一般 新品=爆品

# 技术栈选型

困扰
- 瞬时高流量
- 超售

瞬时高流量
- 多进程 -> php fpm模式
- 多线程 -> java
- 异步 -> node

为什么nginx、redis性能好 -> epoll

什么是epoll?

i/o多路复用 网络i/o 以一次读为例

- 等待内核准备数据
- 内核拷贝数到用户态

- 阻塞i/o
- 非阻塞i/o
- i/o多路复用
- 异步i/o

<!-- ![](https://segmentfault.com/img/bVm1c3)
![](https://segmentfault.com/img/bVm1c4)
![](https://segmentfault.com/img/bVm1c5)
![](https://segmentfault.com/img/bVm1c8) -->

- `int epoll_create(int size)` 创建一个句柄`int epfd`
- `int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event)` 注册事件 `op 操作，增删改事件` `fd 待监测的链接套接字` `event 事件`
- `int epoll_wait(int eqfd, struct epoll_event* events, int maxevents, int timeout)` 返回已发生的事件们 `events 已发生的事件们`

```c
struct eventpoll {
    ...
    // 红黑树 储存epoll_ctl注册的事件
    // 添加的事件会与与设备驱动程序建立回调关系
    struct rb_root rbr;
    // 双向链表 存储epoll_wait返回已发生的事件们
    // 内核的ep_poll_callback会把发生的事件放在这里
    struct list_head rdllist;
    ...
}
```

结果：一个进程或线程可以同时处理多个链接，i/o多路复用的是进程或者线程

协程 -> go

为什么go的协程性能好？

GMP

![](https://user-gold-cdn.xitu.io/2019/12/30/16f55033b4edcf10?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

如何解决超售问题？ -> 并发问题

- 加锁
- 串行化
- 原子操作

原子操作高性能的原因？

轻量，基于CPU指令实现，CAS（Compare-and-Swap），即比较并替换

<!-- 竞争条件是由于异步的访问共享资源，并试图同时读写该资源而导致的，使用互斥锁和通道的思路都是在线程获得到访问权后阻塞其他线程对共享内存的访问，而使用原子操作解决数据竞争问题则是利用了其不可被打断的特性。 https://juejin.im/post/5ee2066fe51d4578455f3caa-->

结论：Go + epoll + 原子操作

# 业务代码

### 读操作

关于读，我们一般遵循如下优先级：

优先级|技术方案|说明|示例
-------|-------|-------|-------
最高|尽可能静态化|对实时性要去不高的数据，尽可能全走CDN|例如获取基础商品信息
高|就近使用内存|优先级服务器内存、远程内存服务|例如秒杀、抢购库存(优先分配库存到服务器内存，其次远程内存服务<又涉及额外网络IO>)
极低|数据库(能不读就不要读)|连接池、sql优化|常见业务

### 写操作

关于写，我们一般会按照数据的一致性要求级别来看：

数据一致性要求|技术方案
------------|------------
不高|先写内存(优先级从服务器内存到远程内存服务) 再异步储存
高|同步完成最关键的任务 异步保证其他任务最终成功


### 削峰限流

从简单到复杂:

简单程度|技术方案
-------|-------
最简单|百分比流量拒绝
简单|原子操作限流(优先级使用服务器内存、其次远程内存服务)
稍麻烦|漏桶、令牌桶限流
麻烦|队列限流

### 服务稳定性

在高并发的场景，有时候为了保证核心业务的正常进行，我们需要对一些次要的业务进行服务降级。简单的降级方案如下：

1. 配置开关降级：手动进行配置开关降级
2. 定时开关降级：自动定时降级

### 系统架构

关于系统架构，不用想的太复杂，简单的拆离此业务即可。

### 运维架构

部署层面，尽可能的把此类服务单独部署。


一个简单的秒杀系统
![](http://cdn.tigerb.cn/20200501175532.png)

一个够用的秒杀系统
![](http://cdn.tigerb.cn/20200501183037.png)

性能再好点的秒杀系统
![](http://cdn.tigerb.cn/20200501200309.png)

支持动态伸缩容的秒杀系统
![](http://cdn.tigerb.cn/20200501200846.png)

公平的秒杀系统
![](http://cdn.tigerb.cn/20200502195413.png)